
2017/10/3

1、实际上 << 其运算符接受两个运算对象
   左侧为ostream对象
   右侧为为要打印的值（可理解为一个计算结果？？？）
   << 运算符的目的就是将右侧的计算结果写入左侧ostream对象中 然后输出
   所以，实际上 运算过程中 一个<< 运算符要已知右侧的计算结果 必然先进行计算右侧结果 而右侧计算对象中如果含有<< 的运算符 必然 又要计算 其中<< 的右侧计算结果 如此迭代 必然先计算 最后一个的 << 运算符的右侧计算结果 然后 依次讲计算结果写入 左侧的ostream 对象
    感觉以上理解过程还是有些问题.....书上竟然说 第一个<< 运算符的结果是第二个运算符的ostream对象，那这样看来 以上理解并不准确 但实际调用过程中依然是从左边计算结果开始的....

2、woc。。。。。昨天用gcc编译含有std的程序出现问题 实际上只要用g++编译即可通过.....
   gcc原本是for c 的编译器 后来包含了其他语言 g++可暂时看成是其中专门为c++编译的编译器
   实际上gcc 和 g++的区别不是编译程序的区别 但是目前可暂时这样认为
   
   至于用gcc编译了c++程序不通过的原因是因为 链接阶段 g++默认链接c++库 而 Gcc没有
   所以才会产生昨天在链接阶段出现错误
   
   用gcc编译需要加一个选项 -lstdc++
   g++可编译c程序


2017/10/4

1、利用花括号进行初始化称为列表初始化

   利用列表初始化时如果初始值存在丢失信息的风险时 编译器将会报错

2、定义指针一定要初始化！！！！
   或者可以等定义相应的对象后在进行定义指针 初始化
   或者初始化为nullptr 定义成空指针

   任何非0指针对应的条件值均为true

3、引用和指针的区别 引用定义的非对象 而 指针定义的是一个对象

   所以无法定义指向引用的指针
  
   但可以定义指针的引用  如： int *&r; // r为一个指向int类型的指针的引用

4、在const对象前面添加上 extern 关键字 将可以在多个文件中共享该const对象

5、 允许常量引用的对象为非常量的
   
   但非常量引用的对象不能为常量的

6、 const int *p // p为指向const int对象的指针
    int *const p // p为一个常量指针 即指向的对象不变 但是可以更改指向的对象值

7、 顶层const 指的是本身的值不会被改变 无论是内置的数据类型还是指针等的
    而 底层const  一般指的是 指针 指向的是一个常量的数据类型

8、 decltype 作用：返回操作数的的数据类型，不实际计算表达式的值

9、定义完类之后要加分号（;）！！！！！！！！！！！！！！！！！！！！！


2017/10/10 

1、 int mian(int argc, char*argv[]) 
    其中括号里的参数是指命令行中的信息 argc是指参数个数， argv则分别存储这些参数

2017/10/12

1、 getline(cin,s) 碰到换行符截止 丢弃了换行符

2、 string的size（）函数返回的是无符号类型 不要和int类型混用
    
3、 string的一些成员函数 
    s.size()
    s.empty()
    s[n]

4、C++从C兼容了C的标准库 C++中将C的标准库头文件去掉.h在前面加上了c
   如 cmath cctype

5、 cctype 中存放了许多关于判断字符的特性 如大小写字母数字之类的判断

6、C++11 范围for语句的使用
   for (declaration: expression)
   statement
   
   expression 提供一个序列 declaration 声明一个变量用于访问序列中的基础元素 直接用auto声明即可
   注意此时 declaration声明的变量不是对序列元素的引用 而是拷贝 即无法改变序列元素的值
   若像改变序列中元素的值应该使用auto &x 的引用定义

   注意这种范围for语句最好的适用条件是要处理序列中的每一个元素

7、 vector初始化 vector<T> ()/ ={}
    一般来说列表初始化中 圆括号是构造 花括号是列值初始化 

8、 vector的主要操作
    v.empty()
    v.size()  // 亦是一个无符号类型整数
    v.push_back()
    
    v[n] //返回的是引用