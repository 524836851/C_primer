
2017/10/3

1、实际上 << 其运算符接受两个运算对象
   左侧为ostream对象
   右侧为为要打印的值（可理解为一个计算结果？？？）
   << 运算符的目的就是将右侧的计算结果写入左侧ostream对象中 然后输出
   所以，实际上 运算过程中 一个<< 运算符要已知右侧的计算结果 必然先进行计算右侧结果 而右侧计算对象中如果含有<< 的运算符 必然 又要计算 其中<< 的右侧计算结果 如此迭代 必然先计算 最后一个的 << 运算符的右侧计算结果 然后 依次讲计算结果写入 左侧的ostream 对象
    感觉以上理解过程还是有些问题.....书上竟然说 第一个<< 运算符的结果是第二个运算符的ostream对象，那这样看来 以上理解并不准确 但实际调用过程中依然是从左边计算结果开始的....

2、woc。。。。。昨天用gcc编译含有std的程序出现问题 实际上只要用g++编译即可通过.....
   gcc原本是for c 的编译器 后来包含了其他语言 g++可暂时看成是其中专门为c++编译的编译器
   实际上gcc 和 g++的区别不是编译程序的区别 但是目前可暂时这样认为
   
   至于用gcc编译了c++程序不通过的原因是因为 链接阶段 g++默认链接c++库 而 Gcc没有
   所以才会产生昨天在链接阶段出现错误
   
   用gcc编译需要加一个选项 -lstdc++
   g++可编译c程序


2017/10/4

1、利用花括号进行初始化称为列表初始化

   利用列表初始化时如果初始值存在丢失信息的风险时 编译器将会报错

2、定义指针一定要初始化！！！！
   或者可以等定义相应的对象后在进行定义指针 初始化
   或者初始化为nullptr 定义成空指针

   任何非0指针对应的条件值均为true

3、引用和指针的区别 引用定义的非对象 而 指针定义的是一个对象

   所以无法定义指向引用的指针
  
   但可以定义指针的引用  如： int *&r; // r为一个指向int类型的指针的引用

4、在const对象前面添加上 extern 关键字 将可以在多个文件中共享该const对象

5、 允许常量引用的对象为非常量的
   
   但非常量引用的对象不能为常量的

6、 const int *p // p为指向const int对象的指针
    int *const p // p为一个常量指针 即指向的对象不变 但是可以更改指向的对象值

7、 顶层const 指的是本身的值不会被改变 无论是内置的数据类型还是指针等的
    而 底层const  一般指的是 指针 指向的是一个常量的数据类型

8、 decltype 作用：返回操作数的的数据类型，不实际计算表达式的值

9、定义完类之后要加分号（;）！！！！！！！！！！！！！！！！！！！！！


   


 